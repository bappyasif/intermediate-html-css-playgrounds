<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDN Tutorial On SVG</title>
</head>

<body>
    <!-- 
        > SVG is an XML language, similar to XHTML, which can be used to draw vector graphics
        > it can be used to create an image either by specifying all the lines and shapes necessary, by modifying already existing raster images, or by a combination of both
        > SVG is supported by all major browsers. A downside is loading SVG can be slow
        > SVG does offer benefits, some of which include having a DOM interface available for it, and not requiring third-party extensions

        Basic ingredients
        > SVG provides elements for circles, rectangles, and simple and complex curves, like html elements
        > A simple SVG document consists of nothing more than the <svg> root element and several basic shapes that build a graphic together
        > In addition there is the <g> element, which is used to group several basic shapes together
        > SVG supports gradients, rotations, filter effects, animations, interactivity with JavaScript, and so on
        > But all these extra features of the language rely on this relatively small set of elements to define the graphics area
        > SVG elements and attributes should all be entered in the case shown here since XML is case-sensitive (unlike HTML)
        > Attribute values in SVG must be placed inside quotes, even if they are numbers
     -->

    <!-- simple example -->
    <!-- 
        The rendering process involves the following:

        > We start with the <svg> root element: 
            > a doctype declaration as known from (X)HTML should be left off because DTD based SVG validation leads to more problems than it solves
            > before SVG 2, to identify the version of the SVG for other types of validation the version and baseProfile attributes should always be used instead
            > Both version and baseProfile attributes are deprecated in SVG 2
            > as an XML dialect, SVG must always bind the namespaces correctly (in the xmlns attribute)
        > background is set to red by drawing a rectangle <rect> that covers the complete image area
        > A green circle <circle> with a radius of 80px is drawn atop the center of the red rectangle (center of circle offset 150px to the right, and 100px downward from the top left corner)
        > text "SVG" is drawn
            > interior of each letter is filled in with white
            > text is positioned by setting an anchor where we want the midpoint to be: in this case, the midpoint should correspond to the center of the green circle
            > Fine adjustments can be made to the font size and vertical position to ensure the final result is aesthetically pleasing
     -->
    <svg version="1.1" width="300" height="200" xmlns="http://www.w3.org/2000/svg">

        <rect width="100%" height="100%" fill="red" />

        <circle cx="150" cy="100" r="80" fill="green" />

        <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>

    </svg>

    <!-- 
        Basic properties of SVG files:
        > first important thing to notice is the order of rendering elements
            > globally valid rule for SVG files is, that later elements are rendered atop previous elements
            > further down an element is the more it will be visible
        
        > SVG files on the web can be displayed directly in the browser or embedded in HTML files via several methods:
            > If the HTML is XHTML and is delivered as type application/xhtml+xml, the SVG can be directly embedded in the XML source
            > If the HTML is HTML5, and the browser is a conforming HTML5 browser, the SVG can also be directly embedded. However, there may be syntax changes necessary to conform to the HTML5 specification
            > SVG file can be referenced with an object element: <object data="image.svg" type="image/svg+xml"></object>
            > Likewise an iframe element can be used: <iframe src="image.svg"></iframe>
            > An img element can theoretically be used too. However, this technique doesn't work in Firefox before 4.0
            > Finally, SVG can be created dynamically with JavaScript and injected into the HTML DOM. With this method, replacement technologies can be implemented for browsers which normally can't process SVG
        
        SVG file types: SVG files come in two flavors: 
        > Normal SVG files are simple text files containing SVG markup, recommended filename extension for these files is ".svg" (all lowercase)
        > Due to the potentially massive size SVG files can reach when used for some applications (e.g., geographical applications), the SVG specification also allows for gzip-compressed SVG files. The recommended filename extension for these files is ".svgz" (all lowercase)

        A word on Webservers:
        > For normal SVG files, servers should send the HTTP headers: 
            Content-Type: image/svg+xml
            Vary: Accept-Encoding
        > For gzip-compressed SVG files, servers should send the HTTP headers:
            Content-Type: image/svg+xml
            Content-Encoding: gzip
            Vary: Accept-Encoding

        The grid:
        > For all elements, SVG uses a coordinate system or grid system similar to the one used by canvas
        > That is, the top left corner of the document is considered to be the point (0,0), or point of origin
        > Positions are then measured in pixels from the top left corner, with the positive x direction being to the right, and the positive y direction being to the bottom
     -->

    <!-- example: defines a rectangle from the upper left corner, that spans from there 100px to the right and to the bottom -->
    <rect x="0" y="0" width="100" height="100" />

    <!-- 
         What are "pixels"?
         > In the most basic case one pixel in an SVG document maps to one pixel on the output device (a.k.a. the screen)
         > But SVG wouldn't have the "Scalable" in its name, if there weren't several possibilities to change this behavior
         > Much like absolute and relative font sizes in CSS, SVG defines absolute units (ones with a dimensional identifier like "pt" or "cm") and so-called user units, that lack that identifier and are plain numbers
         > Without further specification, one user unit equals one screen unit. To explicitly change this behavior, there are several possibilities in SVG
            <svg width="100" height="100">
         > above element defines a simple SVG canvas with 100x100px. One user unit equals one screen unit
            <svg width="200" height="200" viewBox="0 0 100 100">
        > whole SVG canvas here is 200px by 200px in size. However, the viewBox attribute defines the portion of that canvas to display
        > These 200x200 pixels display an area that starts at user unit (0,0) and spans 100x100 user units to the right and to the bottom
        > This effectively zooms in on the 100x100 unit area and enlarges the image to double size
        > current mapping (for a single element or the whole image) of user units to screen units is called user coordinate system
        > Apart from scaling the coordinate system can also be rotated, skewed and flipped
        > default user coordinate system maps one user pixel to one device pixel
      -->

    <!-- 
        Basic shapes
        > There are several basic shapes used for most SVG drawing
        > To insert a shape, you create an element in the document
        > Different elements correspond to different shapes and take different parameters to describe the size and position of those shapes
     -->
    <?xml version="1.0" standalone="no"?>
    <svg width="200" height="250" version="1.1" xmlns="http://www.w3.org/2000/svg">

        <rect x="10" y="10" width="30" height="30" stroke="black" fill="transparent" stroke-width="5" />
        <rect x="60" y="10" rx="10" ry="10" width="30" height="30" stroke="black" fill="transparent" stroke-width="5" />

        <circle cx="25" cy="75" r="20" stroke="red" fill="transparent" stroke-width="5" />
        <ellipse cx="75" cy="75" rx="20" ry="5" stroke="red" fill="transparent" stroke-width="5" />

        <line x1="10" x2="50" y1="110" y2="150" stroke="orange" stroke-width="5" />
        <polyline points="60 110 65 120 70 115 75 130 80 125 85 140 90 135 95 150 100 145" stroke="orange"
            fill="transparent" stroke-width="5" />

        <polygon points="50 160 55 180 70 180 60 190 65 205 50 195 35 205 40 190 30 180 45 180" stroke="green"
            fill="transparent" stroke-width="5" />

        <path d="M20,230 Q40,205 50,230 T90,230" fill="none" stroke="blue" stroke-width="5" />
    </svg>

    <!-- 
        rectangle": <rect> element draws a rectangle on the screen:
            > There are 6 basic attributes that control the position and shape of the rectangles on screen
            > one on the right has its rx and ry parameters set, giving it rounded corners. If they're not set, they default to 0
        > 
        x: The x position of the top left corner of the rectangle.
        y: The y position of the top left corner of the rectangle.

        width: width of the rectangle

        height: height of the rectangle

        rx: x radius of the corners of the rectangle

        ry: y radius of the corners of the rectangle
    -->
    <svg width="101" height="101" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <rect x="10" y="10" width="30" height="30" fill="yellow" />
        <rect x="60" y="10" rx="10" ry="10" width="30" height="30" fill="yellow" />
    </svg>

    <!-- 
        Circle: <circle> element draws a circle on the screen: 
        > It takes 3 basic parameters to determine the shape and size of the element
            > r: radius of the circle.
            > cx: x position of the center of the circle.
            > cy: y position of the center of the circle. 
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <circle cx="25" cy="75" r="20" fill="yellow" />
    </svg>

    <!-- 
        Ellipse: An <ellipse> is a more general form of the <circle> element
        > where you can scale the x and y radius (commonly referred to as the semimajor and semiminor axes in maths) of the circle separately 
            > rx:  radius of the ellipse.
            > ry: cy radius of the ellipse.
            > cx: x position of the center of the ellipse.
            > cy: y position of the center of the ellipse.
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <ellipse cx="75" cy="75" rx="20" ry="5" fill='yellow' />
    </svg>

    <!-- 
        Line:
        > <line> element takes the positions of two points as parameters and draws a straight line between them
            > x1: x position of point 1.
            > y1: y position of point 1.
            > x2: x position of point 2.
            > y2: y position of point 2.
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <line x1="10" x2="50" y1="110" y2="150" stroke="yellow" stroke-width="5" />
    </svg>

    <!-- 
        Polyline: A <polyline> is a group of connected straight lines:
        > Since the list of points can get quite long, all the points are included in one attribute:
            > points: 
                > A list of points
                > Each number must be separated by a space, comma, EOL, or a line feed character
                > Each point must contain two numbers: an x coordinate and a y coordinate
                > So, the list (0,0), (1,1), and (2,2) would be written as 0, 0 1, 1 2, 2
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <polyline points="60, 110 65, 120 70, 115 75, 130 80, 125 85, 140 90, 135 95, 150 100, 145" stroke="yellow" />
    </svg>

    <!-- 
        Polygon: A <polygon> is similar to a <polyline>, in that it is composed of straight line segments connecting a list of points:
        > For polygons though, the path automatically connects the last point with the first, creating a closed shape
        >  A rectangle is a type of polygon, so a polygon can be used to create a <rect/> element in cases where you need a little more flexibility
        > points:
            > A list of points, each number separated by a space, comma, EOL, or a line feed character
            > Each point must contain two numbers: an x coordinate and a y coordinate
            > So, the list (0,0), (1,1), and (2,2) would be written as 0, 0 1, 1 2, 2
            > drawing then closes the path, so a final straight line would be drawn from (2,2) to (0,0)
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <polygon points="60, 110 65, 120 70, 115 75, 130 80, 125 85, 140 90, 135 95, 150 100, 145" stroke="yellow" />
    </svg>

    <!-- 
        Path: A <path> is the most general shape that can be used in SVG:
        > Using a path element, you can draw rectangles (with or without rounded corners), circles, ellipses, polylines, and polygons 
        > Basically any of the other types of shapes, bezier curves, quadratic curves, and many more
        > d: A list of points and other information about how to draw the path
     -->
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
        <path d="M20,230 Q40,205 50,230 T90,230" fill="none" stroke="blue" stroke-width="5" />
    </svg>

    <!-- Path -->
    <!-- 
        > <path> element is the most powerful element in the SVG library of basic shapes
        > It can be used to create lines, curves, arcs, and more
        > Paths create complex shapes by combining multiple straight lines or curved lines
        > Complex shapes composed only of straight lines can be created as <polyline>s
        > <polyline>s require a lot of small straight lines to simulate curves, and don't scale well to larger sizes
        > shape of a <path> element is defined by one parameter: d
        > d attribute contains a series of commands and parameters used by those commands
        > Each of the commands is instantiated (for example, creating a class, naming and locating it) by a specific letter
        > to move to (10,10) the command to use would be M 10 10, After that, the parser begins reading for the next command
        > All of the commands also come in two variants. An uppercase letter specifies absolute coordinates on the page, and a lowercase letter specifies relative coordinates (e.g., move 10px up and 7px to the left from the last point)
        > Coordinates in the d parameter are always unitless and hence in the user coordinate system
    -->
    <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 10" />
        <!-- Points -->
        <circle cx="10" cy="10" r="2" fill="red" />
    </svg>

    <!-- 
        Line commands:
        > There are five line commands for <path> nodes
            > first command is the "Move To" or M: It takes two parameters, a coordinate (x) and coordinate (y) to move to
            > "Move To" command appears at the beginning of paths to specify where the drawing should start
            > There are three commands that draw lines:
                > most generic is the "Line To" command, called with L: L takes two parameters—x and y coordinates—and draws a line from the current position to a new position
                > There are two abbreviated forms for drawing horizontal and vertical lines, H draws a horizontal line, and V draws a vertical line, Both commands only take one parameter since they only move in one direction
            > We can shorten the above path declaration a little bit by using the "Close Path" command, called with Z
                > This command draws a straight line from the current position back to the first point of the path
                > It is often placed at the end of a path node, although not always
                > There is no difference between the uppercase and lowercase command
            > relative forms of these commands can also be used to draw the same picture
                > Relative commands are called by using lowercase letters, and rather than moving the cursor to an exact coordinate, they move it relative to its last position
                > For instance, since our box is 80×80, the <path> element could have been written as:  <path d="M 10 10 h 80 v 80 h -80 Z" fill="transparent" stroke="black"/>
                > path will move to point (10,10) and then move horizontally 80 points to the right, then 80 points down, then 80 points to the left, and then back to the start
     -->
    <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
        <!-- line command -->
        <!-- <path d="M 10 10 H 90 V 90 H 10 L 10 10" stroke="green" /> -->

        <!-- shorten form -->
        <path d="M 10 10 H 90 V 90 H 10 Z" fill="transparent" stroke="green" />

        <!-- relative forms -->
        <path d="M 10 10 h 80 v 80 h -80 Z" fill="yellow" stroke="green" />

        <!-- Points -->
        <circle cx="10" cy="10" r="2" fill="red" />
        <circle cx="90" cy="90" r="2" fill="red" />
        <circle cx="90" cy="10" r="2" fill="red" />
        <circle cx="10" cy="90" r="2" fill="red" />
    </svg>

    <!-- 
        Curve commands: There are three different commands that can be used to create smooth curves:
        > Two of those curves are Bézier curves, and the third is an "arc" or part of a circle
        > There are an infinite number of Bézier curves, but only two simple ones are available in <path> elements: a cubic one, called with C, and a quadratic one, called with Q

        Bézier Curves: cubic curve, C, is the slightly more complex curve
        > Cubic Béziers take in two control points for each point
        > Therefore, to create a cubic Bézier, three sets of coordinates need to be specified
            >  C x1 y1, x2 y2, x y (or) c dx1 dy1, dx2 dy2, dx dy
            > last set of coordinates here (x,y) specify where the line should end
            > other two are control points
            > (x1,y1) is the control point for the start of the curve, and (x2,y2) is the control point for the end
            > control points essentially describe the slope of the line starting at each point
            > Bézier function then creates a smooth curve that transfers from the slope established at the beginning of the line, to the slope at the other end
     -->
     <!-- As the curves move toward the right, the control points become spread out horizontally -->
     <!-- As the curves move downward, they become further separated from the end points -->
     <!-- thing to note here is that the curve starts in the direction of the first control point, and then bends so that it arrives along the direction of the second control point. -->
     <!-- Several Bézier curves can be stringed together to create extended, smooth shapes -->
     <!-- Often, the control point on one side of a point will be a reflection of the control point used on the other side to keep the slope constant. In this case, a shortcut version of the cubic Bézier can be used, designated by the command S (or s):  S x2 y2, x y (or) s dx2 dy2, dx dy
 -->
     
    <svg width="190" height="160" xmlns="http://www.w3.org/2000/svg">

        <path d="M 10 10 C 20 20, 40 20, 50 10" stroke="green" fill="red" />
        <path d="M 70 10 C 70 20, 110 20, 110 10" stroke="green" fill="red" />
        <path d="M 130 10 C 120 20, 180 20, 170 10" stroke="green" fill="red" />
        <path d="M 10 60 C 20 80, 40 80, 50 60" stroke="green" fill="red" />
        <path d="M 70 60 C 70 80, 110 80, 110 60" stroke="green" fill="red" />
        <path d="M 130 60 C 120 80, 180 80, 170 60" stroke="green" fill="red" />
        <path d="M 10 110 C 20 140, 40 140, 50 110" stroke="green" fill="red" />
        <path d="M 70 110 C 70 140, 110 140, 110 110" stroke="green" fill="red" />
        <path d="M 130 110 C 120 140, 180 140, 170 110" stroke="green" fill="red" />

    </svg>


</body>

</html>