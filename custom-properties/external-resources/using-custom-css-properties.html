<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Using custom css properties</title>
</head>

<body>
    <!-- 
        >> For some CSS declarations, it is possible to declare this higher in the cascade and let CSS inheritance solve this problem naturally
        >> By declaring a custom property on the :root pseudo-class and using it where needed throughout the document, a CSS author can reduce the need for repetition

     -->
    <style>
        /* :root, */
        body {
            --main-bg-color: brown;
        }

        .one {
            color: white;
            background-color: var(--main-bg-color);
            margin: 10px;
            width: 50px;
            height: 50px;
            display: inline-block;
        }

        .two {
            color: white;
            background-color: black;
            margin: 10px;
            width: 150px;
            height: 70px;
            display: inline-block;
        }

        .three {
            color: white;
            background-color: var(--main-bg-color);
            margin: 10px;
            width: 75px;
        }

        .four {
            color: white;
            background-color: var(--main-bg-color);
            margin: 10px;
            width: 100px;
        }

        .five {
            background-color: var(--main-bg-color);
        }
    </style>
    <div class="one">
        <div class="two">
            <div class="three">here!!</div>
            <div class="four">here..</div>
        </div>
    </div>

    <!-- 
        Inheritance of custom properties

        >> Custom properties do inherit
        >> This means that if no value is set for a custom property on a given element, the value of its parent is used
        >> consider this following scenario: 
            <div class="one">
                <div class="two">
                    <div class="three"></div>
                    <div class="four"></div>
                </div>
            </div>
            >> with this following css:
                .two {
                --test: 10px;
                }

                .three {
                --test: 2em;
                }
            >> results of var(--test) are: 
                >> for class="two" element: 10px
                >> for class="three" element: 2em
                >> for class="four" element: 10px (inherited from its parent)
                >> for class="one" element: invalid value, which is the default value of any custom property
        >> custom properties are computed where it is needed, not stored for use in other rules
            >> For instance, you cannot set a property for an element and expect to retrieve it in a sibling's descendant's rule
            >> property is only set for the matching selector and its descendants, like any normal CSS

    
        Custom property fallback values
        >> Using the var() function, you can define multiple fallback values when the given variable is not yet defined
        >> this can be useful when working with Custom Elements and Shadow DOM
        >> Fallback values aren't used to fix the browser compatibility
        >> If the browser doesn't support CSS custom properties, the fallback value won't help
        >> It's just a backup for the browser which supports CSS custom properties to choose a different value if the given variable isn't defined or has an invalid value
        >> first argument to the function is the name of the custom property to be substituted
        >> second argument to the function, if provided, is a fallback value, which is used as the substitution value when the referenced custom property is invalid
        >> If that second parameter is invalid, such as if a comma-separated list is provided, the fallback will fail
        >> consider this: 
            .two {
            /* Red if --my-var is not defined */
            color: var(--my-var, red);
            }

            .three {
            /* pink if --my-var and --my-background are not defined */
            background-color: var(--my-var, var(--my-background, pink));
            }

            .three {
            /* Invalid: "--my-background, pink" */
            background-color: var(--my-var, --my-background, pink);
            }

            >> Including a custom property as a fallback, as seen in the second example above, is the correct way to provide more than one fallback
            >> such technique has been seen to cause performance issues as it takes more time to parse through the variables
            >> syntax of the fallback, like that of custom properties, allows commas: 
                >> For example, var(--foo, red, blue) defines a fallback of red, blue â€” anything between the first comma and the end of the function is considered a fallback value
    
            
        Handling invalid custom properties
        >> Each CSS property can be assigned a defined set of values
        >> If you try to assign a value to a property that is outside its set of valid values, it's considered invalid
        >> When the browser encounters an invalid value for a normal property, it discards the value, and elements are assigned the values that they would have had if the declaration simply did not exist
        >> However, when the values of custom properties are parsed, the browser doesn't yet know where they will be used, so it must consider nearly all values as valid
        >> When the browser encounters an invalid var() substitution, then the initial or inherited value of the property is used
        >> Properties and custom variables can lead to invalid CSS statements, leading to the new concept of valid at computed time
     -->

    <!-- 
         Invalid normal properties

         >> In this example we attempt to apply a value of 16px to the color property
         >> Because this is invalid, the CSS is discarded and the result is as if the rule did not exist, so the previous color: blue rule is applied instead, and the paragraph is blue
      -->
    <div class="invalid-normal">
        <style>
            .invalid-normal p {
                color: blue;
            }

            .invalid-normal p {
                color: 16px;
            }
        </style>
        <p>This paragraph is initially black.</p>
    </div>

    <!-- 
        Invalid custom properties

        >> This example is just like the last one, except we use a custom property
        >> As expected, the browser substitutes the value of --text-color in place of var(--text-color), but 16px is not a valid property value for color
        >> After substitution, the property doesn't make sense
        >> browser handles this situation in two steps:
            >> Check if the property color is inheritable
            >> It is, but this <p> doesn't have any parent with the color property set, s we move onto next step
            >> Set the value to its default initial value, which is black
     -->
    <div class="invalid-custom">
        <style>
            .invalid-custom {
                --text-color: 16px;
            }

            .invalid-custom p {
                color: blue;
            }

            .invalid-custom p {
                color: var(--text-color);
            }
        </style>
        <p>This paragraph is initially black.</p>
    </div>

    <!-- 
        Values in JavaScript

        >> To use the values of custom properties in JavaScript, it is just like standard properties

        // get variable from inline style
        element.style.getPropertyValue("--my-var");

        // get variable from wherever
        getComputedStyle(element).getPropertyValue("--my-var");

        // set variable on inline style
        element.style.setProperty("--my-var", jsVar + 4);

     -->
</body>

</html>